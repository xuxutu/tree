//常谋未来事，做好当下事

1.初始化列表与赋值的区别

class ABEntry //address book entry
{
public:
    ABEntry(const string& name,const string& address)
    {
        theName=name;
        theAddress=address;
        //对象的成员变量的初始化动作发生在进入构造函数本之前
        //default构造先设初值
        //然后进行赋值
        //浪费了default构造函数的一切作为
    }

private:
  string theName;
  string theAddress;
};


class BBEntry
{
public:
    BBEntry(const string& name,const string& address) : theName(name),theAddress(address)
        //初始化列表中的实参被拿去直接当构造函数的实参
        //theName 直接以name为初值进行构造
        //theaddress 直接以address为初值进行构造
    {

    }
private:
  string theName;
  string theAddress;
};

2.如果那些成员变量在初始化列表中没有被指定初值，编译器会为用户自定义类型之成员变量自动调用default构造


3.如果成员变量是const或引用，她们就一定需要初值，不能被赋值。
class test
{
public:
  test() : a(0)
  {

  }

  void show()
  {
      cout<<"a="<<a<<endl;
  }

private:
  const int a;
};

4.c++有着十分固定的"成员初始化次序"，次序总是相同。
  4.1 base classes总是更早于其derived classes被初始化。
  4.2 class的成员变量总是以其声明次序被初始化。                                        

5.non-local static 对象
  程序结束时static对象会被自动销毁，它们的析构函数会在main（）函数结束后被调用
  5.1 函数内的static对象称为local static对象
  5.2 其他static对象称为non-local static对象

6.c++对"定义于不同编译单元内的某个non-local static 对象"的初始化次序并无明确定义
  6.1 解决这类次序问题，要将local static对象替换 non-local static 对象
  6.2 local static 对象的特点
      6.2.1 函数内的local static对象会在该函数调用期间且首次遇上该对象之定义式时被初始化
      6.2.2 不调用函数，就不会引发构造和析构成本  

