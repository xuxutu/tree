  2.1 信息存储
      2.1.1 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。实际的是实现是将动态随即访问存储器、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。
      2.1.2 C编译器把每个指针和类型信息联系在一起，这样就可以根据指针值的类型，生成不同的机器级代码来访问存储在指针所指向位置处的值。尽管c编译器维护着这个类型信息，但是它生成的实际机器级程序并不包含数据类型的信息。
  2.1.1 16进制表示法
  2.1.2 字数据大小
        每台计算机都有一个字长（word size），指明指针数据的标称大小（nominal size）。字长决定的最重要的系统参数就是虚拟空间的最大大小。
        ISO C99 引入了一类数据类型，int32_t,int64_t,其类型大小是固定的，不随编译器和机器设置而变化。对于程序员来说，使用确定大小的整形类型是准确控制数据表示的最佳途径。
        程序员应该力图使他们的程序在不同的机器和编译器上可移植。可移植的一个方面就是，使程序对不同数据类型的确切大小不敏感
  2.1.3 小端法：从最低有效字节到最高有效字节的顺序存储
        大端法：从最高有序字节到最低有效字节的顺序存储
  2.1.4 文本数据比二进制文件具有更强的平台独立性
  
  2.1.5 对于同一个程序，不同的机器类型使用不同的且不兼容的指令和编码方式，因此二进制代码是不兼容的。二进制代码很少能在不同的机器和操作系统组合之间移植
        从机器的角度来看，程序仅仅只是字节序列。机器没有关于原始源程序的任何信息，除了有些用来帮助调式的辅助表以外
  2.1.6 布尔运算 &（and） |（or）^(exclusive-or) ~(not) 
  
  2.1.7 c语言中的位级运算
        确定一个位级表达式的结果最好的方法，就是将16进制的参数扩展成二进制表示并执行二进制运算，然后再转换回16进制
        掩码运算
        0^1=1
        1^1-0
        与1抑或可以实现指定按位取反
        0^0=0
        1^0=1
  
  2.1.8 逻辑运算
        按位运算与逻辑运算的区别
        1.按位运算只有在特殊情况下才与逻辑运算结果相同
        2.如果逻辑运算符号左边的表达式的值的结果决定整体结果，那么右边表达式将不会进行
  2.1.9 移位运算
        C语言标准并没有明确定义对于有符号数应该使用哪种类型的右移（算术右移或逻辑右移都可以）
        实际上，几乎所有的编译器/机器组合都对有符号数使用算术右移。
        
        当k>w时，实际移位是k%W

        +优先级比移位高
 2.2.3 反码 最高为权值为2的n次方减1，+0=0；-0=1111(w=4)
       原码 最高位只表示符号位，+0=0000，-0=1000 
       浮点数有用原码表示
 
2.2.4 补码理解
     w=4，对于-7，2的4次方-7=16-7=9=1001（u）=-7（t）
          对于-6，2的4次方-6=10-6=10=1010（u）=-6（t）

     反码
     w=4,对于-7，2的4次方-1-7=8=1000

2.2.5 定义无符号常量 后缀加U/u
     
      当一个数是有符号的，一个数是无符号的，c语言就会隐式地将有符号数转换为无符号数。这种转换会影响><关系运算符的结果

2.2.6 扩展一个数字的位表示
      
     
2.3 整数运算
    
    2.3.1 无符号加法

    2.3.2 补码加法      
          
     
