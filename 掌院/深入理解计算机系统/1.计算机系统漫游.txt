1.本书要阐明的问题：硬件和软件组件是如何影响程序的正确性和性能的？

2.读者的学习目标：完全理解底层计算机系统以及它对应用程序的影响

3.本书可以让读者学会：
  3.1 如何避免由计算机表示数字的方式引起的奇怪的数字错误
  3.2 你将会学会怎样通过一些小窍门来优化自己的c代码，以充分利用现代处理器和存储器系统的设计。
  3.3 你将了解编译器是如何实现系统调用的，以及如何利用这些知识来避免缓冲区溢出错误带来的安全漏洞，这些弱点给网络和因特网软件带来了巨大的麻烦。
  3.4 你将学会如何识别和避免链接时那些令人讨厌的错误，他们困扰着普通的程序员。    3.5 你将学会如何编写自己的unix shell、自己的动态存储分配包，甚至于自己的we服        务器。
  3.6 你会认识并发带来的希望和陷阱，这个主题随着单个芯片集成了多个处理器核变得        越来越重要

4.Gcc编译过程
  4.1 预处理器将.c文件处理成.i文件。将#include包含的文件导入
  4.2 编译器将.i文件翻译成.s文件，汇编语言程序
  4.3 汇编器将.s文件打包成可重定位目标程序，机器语言指令
  4.4 链接器将用到的目标文件合并（printf.o)，可执行目标程序

5.了解编译器如何工作的益处
  
  5.1 优化程序性能（3、5、6章解决）
      5.1.1 一个switch语句是否总是比一系列的if-else语句高效地多？
      5.1.2 一个函数调用的开销有多大？
      5.1.3 while循环比for循环更有效吗？
      5.1.4 指针引用比数组索引更有效吗？
      5.1.5 为什么将循环求和的结果放到一个本地的变量中，会比将其放到一个通过引              用传递过来的参数中，运行起来快很多呢？
      5.1.6 为什么我们只是简单地重新排列一下算术表达式中的括号，就能让函数运行的            更快呢
  5.2 理解链接时出现的错误（7章解决）
      最令人困扰的程序错误往往与链接器操作有关，尤其是当你构建大型的软件系统时        ，如：
      5.2.1 链接器报告说，它无法解析一个引用  
      5.2.2 静态变量和全局变量的区别是什么？
      5.2.3 在不同的文件定义两个相同的全局变量，会发生什么？
      5.2.4 静态库和动态库的区别是什么？
      5.2.5 我们在命令行上排列库有什么影响？
      5.2.6 为什么有些链接错误直到运行时才出现？
  5.3 避免安全漏洞（3章解决）
      5.3.1 缓冲区溢出错误是造成大多数网络和internet服务器上安全漏洞的主要原因              。存在这些错误是因为很少有程序员能够理解，需要限制从不受信任的源接              受数据的数量和格式。
      5.3.2 学习安全编程的第一步就是理解数据和控制信息存储在程序栈上的方式会引起            的后果。
      5.3.3 我们将在第三章描述堆栈原理和缓冲区溢出错误，作为学习汇编语言的一部分      5.3.4 我们还将学习程序员、编译器和操作系统可以用来降低攻击威胁的方法 
      
6. cpu的基本操作
   6.1 加载：从主存复制一个字节或一个字到寄存器，以覆盖寄存器原来的内容
   6.2 存储：从寄存器复制一个字节或一个字到主存某个位置，以覆盖这个位置上原来的              内容
   6.3 操作：把两个寄存器的内容复制到ALU，ALU对这两个字做算术运算，并将结果存放              到一个寄存器中，以覆盖这个寄存器原来的内容
   6.4 跳转：从指令本身抽取一个字，并将这个字复制到程序计数器中，以覆盖pc中原来              的值
7. 高速缓存存储器（6章解决）
   7.1 意识到高速缓存存储器存在的应用程序员能够利用高速缓存将程序的性能提高一个        数量级。
   7.2 存储器层次结构的主要思想是上一层的存储器作为低一层存储器的高速缓存，程序        员也可以利用对整个存储器结构的理解来提高程序性能。
8. 操作系统
   8.1 操作系统提供的两个功能
       8.1.1 防止硬件被失控的应用程序滥用
       8.1.2 向应用程序提供简单一致的机制来控制复杂又大不相同的低级硬件设备
   8.2 操作系统通过几个基本的抽象概念来实现以上两个功能
       8.2.1 文件是是对i/o设备的抽象表示
       8.2.2 虚拟内存是对主存和磁盘I/O设备的抽象表示
       8.2.3 进程则是对处理器、主存和I/O设备的抽象表示。
9. 进程是计算机科学中最成功最重要的概念之一（8章）
   9.1 操作系统保持跟踪进程运行所需的所有状态信息。这种状态就是上下文。包括许多        信息，PC和寄存器的当前值，以及主存中的内容。
   9.2 从一个进程切换到另一个进程的转换是由操作系统内核来管理的。内核是操作系统        常驻主存的部分 
   9.3 内核并不是一个独立的进程。相反，它是系统管理全部进程所用代码和数据结构的        集合
10. 多进程与多线程（12章）

11.虚拟内存（第9章）
   虚拟内存的运作需要硬件和操作系统软件之间精密复杂的交互，包括对处理器生成的每    个地址的硬件编译。基本思想是把一个进程虚拟内存的内容复制到一个磁盘上，然后用    主存作为磁盘的高速缓存
   11.1 程序代码和数据区
   11.2 堆区
   11.3 共享库（C标准库和数学库）
   11.4 栈
   11.5 内核虚拟内存（只有内核有读写调用权限）

12.文件
   12.1 文件就是字节序列。系统中所有输入输出都是通过使用一小组称为Unix I/O的系统        函数调用读写文件来实现的
   12.2 文件为应用程序提供了一个统一的视图，来看待系统中可能含有的各式各样的I/O         设备。

13.系统之间利用网络通信（11章）

14.重要主题
   系统是是硬件和软件相互交织的集合体，它们必须共同协作以达到运行应用程序的目的    。

15.并发和并行
   数字计算机的整个历史中，有两个需求是驱动进步的持续动力，一个是计算机做的更多    ，一个是计算机做得更快

16. 计算机系统中的一个重大主题就是提供不同层次的抽象展示，来隐藏实际实现的复杂性

17.Amdahl law
   17.1 当我们对系统的某个部分加速时，其对整体性能的影响，取决于该部分的重要性和加速程度
   17.2 若假设系统执行某个应用程序所需时间为T1，优化后的时间为T2，用S表示（T1/T2），则公式为：S=1/（1-a+a/k)
   17.3 假设系统某个部分的初始时间与T1的初始比值为a,则这部分的初始时间为a*T1,然后我们给这部分优化，优化的比例因子为k，则优化后这部分的时间a*T1/k
        17.3.1 我们先把T1拆开：
               T1=a*T1+(1-a)*T1
        17.3.2 将优化后的时间带入
               T2=a*T1+(1-a)*T1/K
        17.3.3 S=T1/T2=1/（1-a+a/k)



                      
